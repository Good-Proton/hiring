# Тестовое задание "Планировщик задач"

* Каждая отдельная задача выглядит следующим образом:
  ```
  interface ITask {
    targetId: number
    action: 'init' | 'prepare' | 'work' | 'finalize' | 'cleanup'
  }
  ```

  Использовать специальные хуки `_onComplete` или `_onExecute` нельзя, они используются для диагностики и логирования.

* Есть специальный класс `Executor` (`src/Executor.ts`), который умеет исполнять одну задачу:
  ```
  Executor.executeTask(task: ITask): Promise<void>
  ```

  В решении нельзя использовать внутреннее состояние `Executor`, только `IExecutor.executeTask()`.

Надо реализовать асинхронную функцию, которая получает на вход очередь
задач `AsyncIterable<ITask>` и максимальное кол-во одновременных "потоков" `maxThreads` и возвращает промис, который будет разрезолвлен, когда все задачи
отработают.

```
async function run(executor: IExecutor, queue: AsyncIterable<ITask>, maxThreads = 0): Promise<{...}>
```
При `maxThreads == 0` ограничения на кол-во одновременных "потоков" нету.

Функция должна исполнить задачи максимально быстро, стараясь как можно больше задач исполнить параллельно. Но, есть ограничение (в нем заключается основная сложность задачи): в один момент времени `Executor` не может исполнять несколько разных задач с одним и тем же `Task.targetId`, но при этом он может исполнять много разных задач с разными `Task.targetId` параллельно.

* Например, если мы вызовем  
  ```
  executor.executeTask({ targetId: 0, action: 'init' });
  executor.executeTask({ targetId: 0, action: 'prepare' });
  ```  
  то, второй вызов кинет исключение.

* При этом  
  ```
  executor.executeTask({ targetId: 0, action: 'init' });
  executor.executeTask({ targetId: 1, action: 'prepare' });
  ```  
  или
  ```
  await executor.executeTask({ targetId: 0, action: 'init' });
  await executor.executeTask({ targetId: 0, action: 'prepare' });
  ```  
  отработают нормально.

При взятии задачи из очереди (вызов `iterator.next()` или итерация через `for ... of`) она автоматически удаляется из очереди, при этом существующие итераторы не инвалидируются. При этом надо учесть, что очередь может быть пополнена во время исполнения задач, а также, никто не гарантирует, что очередь конечна в принципе.

Критерий остановки исполнения функции `run()`: все полученные из очереди задачи выполнены и в очереди больше нету новых новых задач.

Все задачи для одного и того же `ITask.targetId` должны быть исполнены последовательно в том порядке, в котором они находятся в очереди.

## Настройка окружения:

* `Node.js version >= 12`

## Установка и подготовка

`npm install`

## Разработка решения
* Заготовка для функции `run()` лежит в `./src/run.ts`. 
* Никакие другие файлы, кроме `./src/run.ts` менять нельзя. 
* Обвязочный код в `run.ts` менять нельзя
* Внутри одного вызова `run()` создавать дополнительные эксземпляры `Executor` нельзя.

## Самостоятельная проверка правильности решения

Для удобства я написал тесты для `run()`, которые проверяют правильность её работы.

`npm run test`

Также тесты генерят детальные отчеты-логи `./test/*.log.html`.

Если при выполнении тестов они зависают в таком состоянии, как ниже на скриншоте, то вероятно вы написали очень неоптимальный алгоритм, который вычитывает слишком много task-ов наперед (больше, чем это необходимо в моменте).

<img width="369" alt="Code_O2bY8fy5hD" src="https://github.com/user-attachments/assets/50278778-01fc-40df-aeda-884de73e7577">


У коректного решения `npm run test` дает следующий вывод:

<img width="440" alt="Code_RLL5YHVeFu" src="https://github.com/user-attachments/assets/76743e2a-5fdb-4d19-8d3e-0a0a8f01c6b8">
